// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: "spi_device"
  import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/mem_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/intr_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson"]
  testpoints: [
    {
      name: smoke
      desc: '''
            Use default SRAM fifo setting. Seq:
            - Write a word data to TX memory and update wptr
            - Send a word SPI transfer
            - Read a word data from RX memory and update rptr
            - Compare the data and check no pending data in SRAM FIFO
            - Repeat above steps'''
      milestone: V1
      tests: ["spi_device_smoke"]
    }
    {
      name: base_random_seq
      desc: '''
            Create 3 parallel threads
            - Write random data to TX memory unless fifo is full
            - Send SPI transfer unless TX is empty or RX is full
            - Read RX memory unless RX is empty'''
      milestone: V2
      tests: ["spi_device_txrx"]
    }
    {
      name: fifo_full
      desc: '''
            Increase the chance to have fifo full by following
            - Reduce delay to write TX memory
            - Increase delay to read RX memory'''
      milestone: V2
      tests: ["spi_device_fifo_full"]
    }
    {
      name: fifo_underflow_overflow
      desc: '''
            Override spi_device_txrx_vseq to send SPI transfer without checking TX/RX fifo, note:
            - When TX is underflow, SW shouldn't update wptr if spi isn't idle, otherwise, spi may
              send mis-aligned data
            - When RX is overflow, data will be lost and if SW update rptr, received data may be
              mis-aligned
            - Ensure underflow/overflow is triggered correctly'''
      milestone: V2
      tests: ["spi_device_fifo_underflow_overflow"]
    }
    {
      name: dummy_sck_and_dummy_csb
      desc: '''
            Drive dummy sck without csb or drive dummy csb without sck, and test no impact on the
            design'''
      milestone: V2
      tests: ["spi_device_dummy_item_extra_dly"]
    }
    {
      name: extra_delay_on_spi
      desc: '''
            Add extra delay between spi clock edge or extra delay between 2 words data
            This is to test host pause transfer for a while without turning off csb and then stream
            in data again'''
      milestone: V2
      tests: ["spi_device_dummy_item_extra_dly"]
    }
    {
      name: async_fifo_reset
      desc: '''Reset async fifo when SPI interface is idle
            TODO: fifo may be fetching data from SRAM? What is the actual usage?'''
      milestone: V2
      tests: []
    }
    {
      name: interrupts
      desc: '''
            Test all supported interrupts:
            - tx/rx lvl
            - rx full
            - rx error
            - overflow/underflow'''
      milestone: V2
      tests: ["spi_device_intr"]
    }
    {
      name: abort
      desc: '''
            Fill the TX_FIFO(async), then abort pending jobs

            Verify that bit 4 of the SPI Device status register is asserted

            Verify that TXF control returns to Idle state
            
            TODO: Need to clarify the behavior in spec'''
      milestone: V2
      tests: []
    }
    {
      name: byte_transfer_on_spi
      desc: '''send spi transfer on byte granularity, and make sure the timer never expires'''
      milestone: V2
      tests: ["spi_device_byte_transfer"]
    }
    {
      name: rx_timeout
      desc: '''
            - Send spi transfer on byte granularity, and timer may expires
            - Only check data in sequence level when timer expires. Monitor and scoreboard don't
              model the timer feature
            - Note: Timeout only for RX'''
      milestone: V2
      tests: []
    }
    {
      name: bit_transfer_on_spi
      desc: '''
            Send spi transfer on bit granularity
            - If TX drives < 7 bits, this byte will be sent in next CSB.
            - If TX drives 7 bits and set CSB to high, this byte won't be sent in next CSB'''
      milestone: V2
      tests: []
    }
    {
      name: extreme_fifo_setting
      desc: '''Set fifo size to 4 bytes(minimum), 2k-4bytes(maximum) and others'''
      milestone: V2
      tests: ["spi_device_extreme_fifo_size"]
    }
    {
      name: mode
      desc: '''
            Configure spi device for passthrough mode
            - Perform passthrough mode transactions, monitor and verify
            - TODO: Requires specification update

            Configure spi device for flash mode
            - Perform flash mode transactions, monitor and verify
            - TODO: Requires specification update

            Configure spi device for TPM mode
            - Check that the return-by-HW register values come from the SW read-writable CSRs
            - Verify that the module latches the CSRs from the SYS_CLK domain into the SPI SCK domain when CSb is asserted
            - Verify that the SW is allowed to modify the return-by-HW registers only when CSb is not active
            '''
      milestone: V2
      tests: []
    }
    {
      name: mem_ecc
      desc: '''
            Backdoor hack memory data to test basic memory ECC behavior limitation:
            - Just cover basic functionality and connectivity
            - Complete verification will be done by PFV'''
      milestone: V2
      tests: []
    }
    {
      name: perf
      desc: '''Run spi_device_fifi_full_vseq with very small delays'''
      milestone: V2
      tests: []
    }
    {
      name: tpm_read
      desc: '''
            Perform a TPM read:
            - Verify that the TPM submodule returns appropriate data for read commands depending on the current read FIFO status, the address, and Locality
            - Confirm that the module sends bytes from the return-by-HW registers to the parallel-to-serial logic right after the address phase.'''
      milestone: V2
      tests: []
    }
    {
      name: tpm_write
      desc: '''
            Perform a TPM write:
            - Verify that the TPM submodule parses the incoming SPI MOSI line and stacks the stream up to the SW accessible registers
            - The SW must decode the command and the address
            - SW reads the data from the write FIFO or pushes data into the read FIFO depending on the command'''
      milestone: V2
      tests: []
    }
    {
      name: tpm_invalid
      desc: '''
            Write a 1 to bit 4 of the TPM configuration register
            - Verify that the TPM submodule returns the invalid data (0xFF) for the out of the max Locality request
            - If it is a write request, confirm that it discards the request

            Write a 0 to bit 4 of the TPM configuration register
            - Verify that the TPM submodule uploads the TPM command and address, the SW is able to write 0xFF to the read FIFO

            Verify that the TPM submodule uploads the TPM commands that do not fall into the FIFO registers (0xD4_XXXX) regardless of invalid_locality bit'''
      milestone: V2
      tests: []
    }
  ]
}
